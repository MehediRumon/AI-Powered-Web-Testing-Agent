<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Web Testing Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .auth-section {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 2rem auto;
            max-width: 400px;
        }

        .main-content {
            display: none;
            padding: 2rem 0;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .card-header {
            background: #f8f9fa;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }

        .card-body {
            padding: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .status {
            padding: 0.75rem;
            border-radius: 4px;
            margin: 1rem 0;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b3d7ff;
        }

        .test-case {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .test-case-actions, .test-result-actions {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .test-result {
            border-left: 4px solid #28a745;
            padding: 1rem;
            margin-bottom: 1rem;
            background: #f8f9fa;
        }

        .test-result.failed {
            border-left-color: #dc3545;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #eee;
        }

        .tab {
            padding: 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab.active {
            border-bottom-color: #667eea;
            color: #667eea;
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
        }

        .tab-content.active {
            display: block;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .file-upload {
            border: 2px dashed #ddd;
            border-radius: 4px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .file-upload:hover {
            border-color: #667eea;
        }

        .hidden {
            display: none !important;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Navigation Bar Styles */
        .navbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.5rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: none;
        }

        .navbar.show {
            display: block;
        }

        .navbar-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .navbar-brand {
            font-size: 1.2rem;
            font-weight: 600;
            color: #667eea;
            text-decoration: none;
        }

        .navbar-nav {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 2rem;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            color: #333;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .nav-link.active {
            background: #667eea;
            color: white;
        }

        .dropdown {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 200px;
            display: none;
            z-index: 1001;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            padding: 0.75rem 1rem;
            color: #333;
            text-decoration: none;
            border-bottom: 1px solid #f8f9fa;
            cursor: pointer;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
        }

        .mobile-menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #333;
        }

        /* Settings Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 1rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
        }

        .close-button:hover {
            color: #333;
        }

        .timing-preset {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timing-preset:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .timing-preset.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .range-slider {
            width: 100%;
            margin: 1rem 0;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .navbar-nav {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                border-top: 1px solid #eee;
                flex-direction: column;
                gap: 0;
                padding: 1rem 0;
            }

            .navbar-nav.show {
                display: flex;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .nav-item {
                width: 100%;
            }

            .nav-link {
                display: block;
                padding: 1rem 2rem;
                border-radius: 0;
            }

            .dropdown-menu {
                position: static;
                border: none;
                box-shadow: none;
                background: #f8f9fa;
                margin-left: 2rem;
            }
        }

        /* Recorder Styles */
        .recorder-section {
            padding: 1rem 0;
        }

        .recorder-controls {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .recorder-controls button {
            flex: 1;
            min-width: 120px;
        }

        .recording-status {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 4px;
            font-weight: 500;
            text-align: center;
            display: none;
        }

        .recording-status.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .recording-status.paused {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            display: block;
        }

        .recording-status.stopped {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        /* Live View Panel Styles */
        .live-view-panel {
            margin: 1rem 0;
            padding: 1rem;
            border: 2px solid #28a745;
            border-radius: 8px;
            background: #f8fff9;
        }

        .live-view-panel h5 {
            margin: 0 0 1rem 0;
            color: #155724;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .live-stats {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .live-stats span {
            background: #e2f3e4;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            border: 1px solid #c3e6cb;
        }

        .live-actions-preview {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .live-action-placeholder {
            padding: 2rem;
            text-align: center;
            color: #6c757d;
            font-style: italic;
        }

        .live-action-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            animation: slideIn 0.3s ease-out;
        }

        .live-action-item:hover {
            background-color: #f8f9fa;
        }

        .live-action-item:last-child {
            border-bottom: none;
        }

        .live-action-type {
            background: #007bff;
            color: white;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            min-width: 60px;
            text-align: center;
        }

        .live-action-description {
            flex: 1;
            font-size: 0.875rem;
        }

        .live-action-time {
            font-size: 0.75rem;
            color: #6c757d;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .recorded-actions {
            margin-top: 2rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
        }

        .actions-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 1rem 0;
        }

        .action-item {
            background: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .action-details {
            flex: 1;
        }

        .action-type {
            font-weight: 600;
            color: #667eea;
        }

        .action-target {
            color: #666;
            font-size: 0.9rem;
        }

        .action-value {
            color: #333;
            font-style: italic;
        }

        .action-remove {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .actions-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .recording-instructions {
            background: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .recording-instructions h5 {
            margin-bottom: 0.5rem;
            color: #667eea;
        }

        .recording-instructions ol {
            margin-left: 1.5rem;
        }

        .recording-instructions li {
            margin-bottom: 0.25rem;
        }

        .btn-primary {
            background: #667eea;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        @media (max-width: 768px) {
            .recorder-controls {
                flex-direction: column;
            }
            
            .recorder-controls button {
                min-width: auto;
            }
            
            .actions-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <h1>🤖 AI-Powered Web Testing Agent</h1>
            <p>Automate your web testing with Playwright and AI</p>
        </div>
    </div>

    <!-- Navigation Bar (shown only when logged in) -->
    <nav id="navbar" class="navbar">
        <div class="navbar-content">
            <a href="#" class="navbar-brand" onclick="scrollToSection('dashboard')">🤖 Testing Agent</a>
            
            <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">☰</button>
            
            <ul class="navbar-nav" id="navbarNav">
                <li class="nav-item">
                    <a class="nav-link active" onclick="setActiveTab('dashboard')" href="#dashboard">Dashboard</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" onclick="setActiveTab('tests')" href="#tests">Test Cases</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" onclick="setActiveTab('results')" href="#results">Results</a>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link" onclick="toggleDropdown(event)">
                        <span id="navbarUsername">User</span> ▼
                    </a>
                    <div class="dropdown-menu">
                        <a class="dropdown-item" onclick="openSettings()">⚙️ Settings</a>
                        <a class="dropdown-item" onclick="openProfile()">👤 Profile</a>
                        <a class="dropdown-item" onclick="logout()">🚪 Logout</a>
                    </div>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Authentication Section -->
    <div id="authSection" class="auth-section">
        <div class="tabs">
            <div class="tab active" onclick="switchAuthTab('login')">Login</div>
            <div class="tab" onclick="switchAuthTab('register')">Register</div>
        </div>
        
        <!-- Login Form -->
        <div id="loginTab" class="tab-content active">
            <form id="loginForm">
                <div class="form-group">
                    <label for="loginUsername">Username</label>
                    <input type="text" id="loginUsername" name="username" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" name="password" required>
                </div>
                <button type="submit">Login</button>
            </form>
        </div>

        <!-- Register Form -->
        <div id="registerTab" class="tab-content">
            <form id="registerForm">
                <div class="form-group">
                    <label for="registerUsername">Username</label>
                    <input type="text" id="registerUsername" name="username" required>
                </div>
                <div class="form-group">
                    <label for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" name="email" required>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" name="password" required>
                </div>
                <button type="submit">Register</button>
            </form>
        </div>
    </div>

    <!-- Main Application -->
    <div id="mainContent" class="main-content">
        <div class="container">
            <!-- Browser Status -->
            <div class="card">
                <div class="card-header">Browser Status</div>
                <div class="card-body">
                    <div id="browserStatus">Checking browser installation...</div>
                    <button id="installBrowsersBtn" class="btn-secondary hidden" onclick="installBrowsers()">Install Browsers</button>
                </div>
            </div>

            <div class="grid">
                <!-- Test Creation -->
                <div class="card">
                    <div class="card-header">Create Test Case</div>
                    <div class="card-body">
                        <div class="tabs">
                            <div class="tab active" onclick="switchTestTab('manual')">Manual</div>
                            <div class="tab" onclick="switchTestTab('ai')">AI Assistant</div>
                            <div class="tab" onclick="switchTestTab('upload')">Upload</div>
                            <div class="tab" onclick="switchTestTab('record')">Record</div>
                        </div>

                        <!-- Manual Test Creation -->
                        <div id="manualTestTab" class="tab-content active">
                            <form id="createTestForm">
                                <div class="form-group">
                                    <label for="testName">Test Name</label>
                                    <input type="text" id="testName" name="name" required>
                                </div>
                                <div class="form-group">
                                    <label for="testUrl">URL</label>
                                    <input type="url" id="testUrl" name="url" required>
                                </div>
                                <div class="form-group">
                                    <label for="testDescription">Description</label>
                                    <textarea id="testDescription" name="description" rows="3"></textarea>
                                </div>
                                <div class="form-group">
                                    <label for="testActions">Test Actions (JSON format)</label>
                                    <textarea id="testActions" name="actions" rows="6" placeholder='[{"type": "navigate", "value": "https://example.com"}, {"type": "click", "selector": "#button"}]'></textarea>
                                </div>
                                <button type="submit">Create Test Case</button>
                            </form>
                        </div>

                        <!-- AI Assistant -->
                        <div id="aiTestTab" class="tab-content">
                            <div class="form-group">
                                <label for="aiInstructions">Describe your test in natural language</label>
                                <textarea id="aiInstructions" rows="4" placeholder="Example: Go to https://example.com, click the login button, enter username 'test@example.com', enter password 'password123', and click submit"></textarea>
                            </div>
                            <button onclick="parseWithAI()">Parse with AI</button>
                            <button onclick="generateFromURL()" class="btn-secondary">📸 Generate from URL (Grok AI)</button>
                            <button onclick="browseAndGenerate()" class="btn-primary">🔍 Browse & Generate</button>
                            
                            <div id="aiResult" class="hidden">
                                <h4>Parsed Test Case:</h4>
                                <pre id="aiParsedResult"></pre>
                                <button onclick="saveAIParsedTest()">Save Test Case</button>
                                <button onclick="saveAndExecuteAIParsedTest()" class="btn-primary">Save & Execute</button>
                            </div>
                        </div>

                        <!-- File Upload -->
                        <div id="uploadTestTab" class="tab-content">
                            <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                                <p>Click to upload CSV/Excel/JSON file with test cases</p>
                                <input type="file" id="fileInput" accept=".csv,.xlsx,.xls,.json" style="display: none;" onchange="uploadFile()">
                            </div>
                            <div id="uploadResult"></div>
                        </div>

                        <!-- Interaction Recorder -->
                        <div id="recordTestTab" class="tab-content">
                            <div class="recorder-section">
                                <h4>Interaction Recorder</h4>
                                <p>Record your interactions on a webpage to automatically generate test cases.</p>
                                
                                <div class="form-group">
                                    <label for="recordTestName">Test Name</label>
                                    <input type="text" id="recordTestName" placeholder="Enter test name" required>
                                </div>
                                
                                <div class="form-group">
                                    <label for="recordTestUrl">Target URL</label>
                                    <input type="url" id="recordTestUrl" placeholder="https://example.com" required>
                                </div>
                                
                                <div class="form-group">
                                    <label for="recordTestDescription">Description (Optional)</label>
                                    <textarea id="recordTestDescription" rows="2" placeholder="Describe what this test will do"></textarea>
                                </div>
                                
                                <div class="recorder-controls">
                                    <button id="startRecordingBtn" onclick="startRecording()" class="btn-primary">
                                        🔴 Start Recording
                                    </button>
                                    <button id="stopRecordingBtn" onclick="stopRecording()" class="btn-secondary" disabled>
                                        ⏹️ Stop Recording
                                    </button>
                                    <button id="pauseRecordingBtn" onclick="pauseRecording()" class="btn-secondary" disabled>
                                        ⏸️ Pause Recording
                                    </button>
                                </div>
                                
                                <div id="recordingStatus" class="recording-status"></div>
                                
                                <!-- Live View Panel -->
                                <div id="liveViewPanel" class="live-view-panel" style="display: none;">
                                    <h5>🔴 Live Recording View</h5>
                                    <div class="live-stats">
                                        <span>Actions: <span id="liveActionCount">0</span></span>
                                        <span>Duration: <span id="liveDuration">00:00</span></span>
                                        <span>Status: <span id="liveStatus">Recording...</span></span>
                                    </div>
                                    <div class="live-actions-preview" id="liveActionsPreview">
                                        <div class="live-action-placeholder">Perform actions on the target page to see them here...</div>
                                    </div>
                                </div>
                                
                                <div id="recordedActions" class="recorded-actions" style="display: none;">
                                    <h5>Recorded Actions:</h5>
                                    <div class="actions-list" id="actionsList"></div>
                                    <div class="actions-controls">
                                        <button onclick="clearRecordedActions()" class="btn-secondary">Clear All</button>
                                        <button onclick="saveRecordedTest()" class="btn-success">Save Test Case</button>
                                    </div>
                                </div>
                                
                                <div id="recordingInstructions" class="recording-instructions">
                                    <h5>How to use:</h5>
                                    <ol>
                                        <li>Enter a test name and target URL</li>
                                        <li>Click "Start Recording"</li>
                                        <li>A new window will open to the target URL</li>
                                        <li>Perform your interactions (clicks, typing, etc.)</li>
                                        <li>Click "Stop Recording" when done</li>
                                        <li>Review and save your test case</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Test Execution -->
                <div class="card">
                    <div class="card-header">Test Execution</div>
                    <div class="card-body">
                        <div class="form-group">
                            <label for="browserType">Browser Type</label>
                            <select id="browserType">
                                <option value="chromium">Chromium</option>
                                <option value="firefox">Firefox</option>
                                <option value="webkit">WebKit</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="headlessMode" checked> Headless Mode
                            </label>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="parallelExecution"> Parallel Execution
                            </label>
                        </div>
                        <div class="form-group" id="maxConcurrencyGroup" style="display: none;">
                            <label for="maxConcurrency">Max Concurrent Tests</label>
                            <select id="maxConcurrency">
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                            </select>
                        </div>
                        <button onclick="executeAllTests()" class="btn-success">Run All Tests</button>
                        <button onclick="loadTestCases()" class="btn-secondary">Refresh Test Cases</button>
                    </div>
                </div>
            </div>

            <!-- Test Cases List -->
            <div class="card">
                <div class="card-header">Test Cases</div>
                <div class="card-body">
                    <div id="testCasesList">Loading test cases...</div>
                </div>
            </div>

            <!-- Test Results -->
            <div class="card">
                <div class="card-header">Test Results</div>
                <div class="card-body">
                    <button onclick="loadTestResults()" class="btn-secondary">Refresh Results</button>
                    <button onclick="generateReport('html')" class="btn-success">Generate HTML Report</button>
                    <button onclick="generateReport('pdf')" class="btn-success">Generate PDF Report</button>
                    <div id="testResultsList">Loading test results...</div>
                </div>
            </div>

            <!-- Logout -->
            <div class="card">
                <div class="card-body" style="text-align: center;">
                    <button onclick="logout()" class="btn-danger">Logout</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">⚙️ Settings</h3>
                <button class="close-button" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="modal-body">
                <div class="form-group">
                    <label for="interactionDelay">Interaction Delay Between Elements</label>
                    <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
                        Configure how long to wait between test interactions (in seconds)
                    </p>
                    
                    <!-- Timing Presets -->
                    <div class="timing-presets" style="margin-bottom: 1.5rem;">
                        <div class="timing-preset" onclick="selectTimingPreset('fast', 1)">
                            <div>
                                <strong>⚡ Fast</strong>
                                <div style="font-size: 0.9rem; color: #666;">1 second delay</div>
                            </div>
                            <div>1s</div>
                        </div>
                        <div class="timing-preset" onclick="selectTimingPreset('normal', 3)">
                            <div>
                                <strong>⏱️ Normal</strong>
                                <div style="font-size: 0.9rem; color: #666;">3 seconds delay</div>
                            </div>
                            <div>3s</div>
                        </div>
                        <div class="timing-preset selected" onclick="selectTimingPreset('slow', 5)">
                            <div>
                                <strong>🐌 Slow</strong>
                                <div style="font-size: 0.9rem; color: #666;">5 seconds delay (default)</div>
                            </div>
                            <div>5s</div>
                        </div>
                    </div>
                    
                    <!-- Custom Timing Slider -->
                    <div class="form-group">
                        <label for="customDelaySlider">Custom Delay: <span id="delayValue">5</span> seconds</label>
                        <input 
                            type="range" 
                            id="customDelaySlider" 
                            class="range-slider" 
                            min="0.5" 
                            max="10" 
                            step="0.5" 
                            value="5"
                            oninput="updateDelayValue(this.value)"
                        >
                        <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #666;">
                            <span>0.5s</span>
                            <span>5s</span>
                            <span>10s</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="enableVisualIndicators" checked> 
                        Enable Visual Interaction Indicators
                    </label>
                    <p style="font-size: 0.9rem; color: #666; margin-top: 0.5rem;">
                        Show green borders and labels during test interactions
                    </p>
                </div>
                
                <!-- API Configuration Section -->
                <div class="form-group" style="border-top: 1px solid #eee; padding-top: 1.5rem; margin-top: 1.5rem;">
                    <h4 style="margin-bottom: 1rem; color: #333;">🔑 API Configuration</h4>
                    
                    <div class="form-group">
                        <label for="openaiApiKey">OpenAI API Key</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input 
                                type="password" 
                                id="openaiApiKey" 
                                placeholder="sk-..."
                                style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;"
                            >
                            <button 
                                type="button" 
                                onclick="toggleApiKeyVisibility('openaiApiKey')" 
                                style="padding: 0.5rem; border: 1px solid #ddd; background: #f8f9fa; border-radius: 4px; cursor: pointer;"
                                title="Toggle visibility"
                            >
                                👁️
                            </button>
                        </div>
                        <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
                            Required for AI-powered test generation. Get your key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI</a>
                        </p>
                        <div id="openaiKeyStatus" style="font-size: 0.8rem; margin-top: 0.5rem;"></div>
                        <button type="button" onclick="testApiConnection('openai')" class="btn-secondary" style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                            Test Connection
                        </button>
                    </div>
                    
                    <div class="form-group">
                        <label for="groqApiKey">Groq API Key</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input 
                                type="password" 
                                id="groqApiKey" 
                                placeholder="gsk_..."
                                style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;"
                            >
                            <button 
                                type="button" 
                                onclick="toggleApiKeyVisibility('groqApiKey')" 
                                style="padding: 0.5rem; border: 1px solid #ddd; background: #f8f9fa; border-radius: 4px; cursor: pointer;"
                                title="Toggle visibility"
                            >
                                👁️
                            </button>
                        </div>
                        <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
                            Required for AI-powered Browse & Test Generation. Get your key from <a href="https://console.groq.com/" target="_blank">Groq</a>
                        </p>
                        <div id="groqKeyStatus" style="font-size: 0.8rem; margin-top: 0.5rem;"></div>
                        <button type="button" onclick="testApiConnection('groq')" class="btn-secondary" style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                            Test Connection
                        </button>
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button onclick="saveSettings()" class="btn-success">Save Settings</button>
                    <button onclick="resetSettings()" class="btn-secondary">Reset to Default</button>
                    <button onclick="closeSettings()" class="btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let authToken = localStorage.getItem('authToken');
        let currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
        let lastParsedTest = null;

        // Settings variables
        let interactionDelay = parseInt(localStorage.getItem('interactionDelay') || '5');
        let enableVisualIndicators = localStorage.getItem('enableVisualIndicators') !== 'false';

        // Navigation functions
        function showNavbar() {
            document.getElementById('navbar').classList.add('show');
            if (currentUser.username) {
                document.getElementById('navbarUsername').textContent = currentUser.username;
            }
        }

        function hideNavbar() {
            document.getElementById('navbar').classList.remove('show');
        }

        function toggleMobileMenu() {
            const nav = document.getElementById('navbarNav');
            nav.classList.toggle('show');
        }

        function toggleDropdown(event) {
            event.preventDefault();
            const dropdown = event.target.closest('.dropdown');
            const menu = dropdown.querySelector('.dropdown-menu');
            menu.classList.toggle('show');
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!dropdown.contains(e.target)) {
                    menu.classList.remove('show');
                }
            }, { once: true });
        }

        function setActiveTab(tabName) {
            // Remove active class from all nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // Add active class to clicked link
            event.target.classList.add('active');
            
            // Scroll to section
            scrollToSection(tabName);
        }

        function scrollToSection(sectionId) {
            const element = document.getElementById(sectionId === 'dashboard' ? 'mainContent' : 
                                                 sectionId === 'tests' ? 'testCasesList' :
                                                 sectionId === 'results' ? 'testResultsList' : 'mainContent');
            if (element) {
                element.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Settings functions
        function openSettings() {
            document.getElementById('settingsModal').classList.add('show');
            // Load current settings
            document.getElementById('customDelaySlider').value = interactionDelay;
            document.getElementById('delayValue').textContent = interactionDelay;
            document.getElementById('enableVisualIndicators').checked = enableVisualIndicators;
            
            // Update preset selection
            updatePresetSelection();
            
            // Load API configuration
            loadApiConfiguration();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        function openProfile() {
            alert('Profile management coming soon!');
        }

        function selectTimingPreset(preset, seconds) {
            // Remove selected class from all presets
            document.querySelectorAll('.timing-preset').forEach(p => {
                p.classList.remove('selected');
            });
            
            // Add selected class to clicked preset
            event.currentTarget.classList.add('selected');
            
            // Update slider and display
            document.getElementById('customDelaySlider').value = seconds;
            document.getElementById('delayValue').textContent = seconds;
        }

        function updateDelayValue(value) {
            document.getElementById('delayValue').textContent = value;
            
            // Update preset selection based on value
            updatePresetSelection();
        }

        function updatePresetSelection() {
            const value = parseFloat(document.getElementById('customDelaySlider').value);
            document.querySelectorAll('.timing-preset').forEach(p => {
                p.classList.remove('selected');
            });
            
            if (value === 1) {
                document.querySelector('.timing-preset:nth-child(1)').classList.add('selected');
            } else if (value === 3) {
                document.querySelector('.timing-preset:nth-child(2)').classList.add('selected');
            } else if (value === 5) {
                document.querySelector('.timing-preset:nth-child(3)').classList.add('selected');
            }
        }

        function saveSettings() {
            // Save interaction delay
            interactionDelay = parseFloat(document.getElementById('customDelaySlider').value);
            localStorage.setItem('interactionDelay', interactionDelay.toString());
            
            // Save visual indicators setting
            enableVisualIndicators = document.getElementById('enableVisualIndicators').checked;
            localStorage.setItem('enableVisualIndicators', enableVisualIndicators.toString());
            
            // Save API configuration
            saveApiConfiguration();
        }

        function resetSettings() {
            // Reset to defaults
            document.getElementById('customDelaySlider').value = 5;
            document.getElementById('delayValue').textContent = '5';
            document.getElementById('enableVisualIndicators').checked = true;
            
            updatePresetSelection();
        }

        // API Configuration functions
        async function loadApiConfiguration() {
            try {
                const response = await apiCall('/api/config/api-keys');
                const config = await response.json();
                
                if (response.ok) {
                    // Update status indicators
                    updateApiKeyStatus('openaiKeyStatus', config.hasOpenAiKey, 'OpenAI');
                    updateApiKeyStatus('groqKeyStatus', config.hasGroqKey, 'Groq');
                    
                    // Clear the input fields for security (don't show actual keys)
                    document.getElementById('openaiApiKey').value = '';
                    document.getElementById('groqApiKey').value = '';
                } else {
                    console.error('Failed to load API configuration:', config.error);
                }
            } catch (error) {
                console.error('Error loading API configuration:', error);
            }
        }

        function updateApiKeyStatus(elementId, hasKey, provider) {
            const element = document.getElementById(elementId);
            if (hasKey) {
                element.innerHTML = `<span style="color: #28a745;">✓ ${provider} API key configured</span>`;
            } else {
                element.innerHTML = `<span style="color: #dc3545;">⚠ ${provider} API key not configured</span>`;
            }
        }

        async function saveApiConfiguration() {
            const openaiKey = document.getElementById('openaiApiKey').value.trim();
            const groqKey = document.getElementById('groqApiKey').value.trim();
            
            // Only send keys that have been changed (non-empty)
            const payload = {};
            if (openaiKey) payload.openai_api_key = openaiKey;
            if (groqKey) payload.groq_api_key = groqKey;
            
            // If no keys to update, just save other settings
            if (Object.keys(payload).length === 0) {
                alert(`Settings saved! Interaction delay: ${interactionDelay}s, Visual indicators: ${enableVisualIndicators ? 'enabled' : 'disabled'}`);
                closeSettings();
                return;
            }
            
            try {
                const response = await apiCall('/api/config/api-keys', {
                    method: 'PUT',
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Update status indicators
                    if (openaiKey) updateApiKeyStatus('openaiKeyStatus', true, 'OpenAI');
                    if (groqKey) updateApiKeyStatus('groqKeyStatus', true, 'Groq');
                    
                    // Clear the input fields
                    document.getElementById('openaiApiKey').value = '';
                    document.getElementById('groqApiKey').value = '';
                    
                    alert(`Settings saved! Interaction delay: ${interactionDelay}s, Visual indicators: ${enableVisualIndicators ? 'enabled' : 'disabled'}, API keys updated.`);
                } else {
                    alert('Error saving API configuration: ' + result.error);
                    return; // Don't close settings if API save failed
                }
            } catch (error) {
                alert('Error saving API configuration: ' + error.message);
                return; // Don't close settings if API save failed
            }
            
            closeSettings();
        }

        // Test API connection function
        async function testApiConnection(service) {
            const statusElementId = service === 'groq' ? 'groqKeyStatus' : 'openaiKeyStatus';
            const statusElement = document.getElementById(statusElementId);
            
            statusElement.innerHTML = '🔄 Testing connection...';
            statusElement.style.color = '#666';
            
            try {
                const response = await apiCall('/api/config/test-connection', {
                    method: 'POST',
                    body: JSON.stringify({ service })
                });
                
                const result = await response.json();
                
                if (result.connected) {
                    statusElement.innerHTML = `✅ ${result.message}`;
                    statusElement.style.color = '#28a745';
                } else {
                    statusElement.innerHTML = `❌ ${result.message}`;
                    statusElement.style.color = '#dc3545';
                }
            } catch (error) {
                statusElement.innerHTML = `❌ Test failed: ${error.message}`;
                statusElement.style.color = '#dc3545';
            }
        }

        function toggleApiKeyVisibility(inputId) {
            const input = document.getElementById(inputId);
            if (input.type === 'password') {
                input.type = 'text';
            } else {
                input.type = 'password';
            }
        }

        // Token validation function
        function validateToken() {
            if (!authToken) {
                return false;
            }
            
            try {
                // Parse the token to check expiration
                const payload = JSON.parse(atob(authToken.split('.')[1]));
                const currentTime = Math.floor(Date.now() / 1000);
                
                if (payload.exp && payload.exp < currentTime) {
                    console.log('Token has expired');
                    showStatus('Your session has expired. Please log in again.', 'error');
                    logout();
                    return false;
                }
                
                return true;
            } catch (error) {
                console.log('Invalid token format:', error);
                logout();
                return false;
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            if (authToken && validateToken()) {
                showMainContent();
                showNavbar();
                checkBrowserStatus();
                loadTestCases();
                loadTestResults();
            } else {
                showAuthSection();
            }
        });

        // Authentication functions
        function switchAuthTab(tab) {
            document.querySelectorAll('.auth-section .tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-section .tab-content').forEach(t => t.classList.remove('active'));
            
            if (tab === 'login') {
                document.querySelector('.auth-section .tab:first-child').classList.add('active');
                document.getElementById('loginTab').classList.add('active');
            } else {
                document.querySelector('.auth-section .tab:last-child').classList.add('active');
                document.getElementById('registerTab').classList.add('active');
            }
        }

        document.getElementById('loginForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);

            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.token;
                    currentUser = result.user;
                    localStorage.setItem('authToken', authToken);
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    showMainContent();
                    checkBrowserStatus();
                    loadTestCases();
                    loadTestResults();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Login failed: ' + error.message, 'error');
            }
        });

        document.getElementById('registerForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);

            try {
                const response = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.token;
                    currentUser = result.user;
                    localStorage.setItem('authToken', authToken);
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    showMainContent();
                    checkBrowserStatus();
                    loadTestCases();
                    loadTestResults();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Registration failed: ' + error.message, 'error');
            }
        });

        function logout() {
            localStorage.removeItem('authToken');
            localStorage.removeItem('currentUser');
            authToken = null;
            currentUser = {};
            hideNavbar();
            showAuthSection();
        }

        function showAuthSection() {
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('mainContent').style.display = 'none';
            hideNavbar();
        }

        function showMainContent() {
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            showNavbar();
        }

        // Utility functions
        function showStatus(message, type) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            
            // Insert at the top of auth section or main content
            const container = authToken ? document.querySelector('.container') : document.getElementById('authSection');
            container.insertBefore(statusDiv, container.firstChild);
            
            setTimeout(() => statusDiv.remove(), 5000);
        }

        function switchTestTab(tab) {
            document.querySelectorAll('.card .tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.card .tab-content').forEach(t => t.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTestTab('${tab}')"]`).classList.add('active');
            document.getElementById(`${tab}TestTab`).classList.add('active');
        }

        // API call helper with token expiration handling
        async function apiCall(url, options = {}) {
            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                }
            };

            try {
                const response = await fetch(url, { ...defaultOptions, ...options });
                
                // Handle token expiration or invalid token
                if (response.status === 403) {
                    const result = await response.json().catch(() => ({}));
                    if (result.error === 'Invalid or expired token') {
                        console.log('Token expired or invalid, logging out user');
                        showStatus('Your session has expired. Please log in again.', 'error');
                        logout();
                        return response; // Return the response so calling code can handle it
                    }
                }
                
                return response;
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        // Browser status check
        async function checkBrowserStatus() {
            try {
                const response = await apiCall('/api/test/browser-status');
                const result = await response.json();
                
                const statusDiv = document.getElementById('browserStatus');
                const installBtn = document.getElementById('installBrowsersBtn');
                
                if (result.status === 'installed') {
                    statusDiv.innerHTML = `<div class="status success">${result.message}</div>`;
                    installBtn.classList.add('hidden');
                } else {
                    statusDiv.innerHTML = `<div class="status error">${result.message}</div>`;
                    installBtn.classList.remove('hidden');
                }
            } catch (error) {
                document.getElementById('browserStatus').innerHTML = 
                    `<div class="status error">Failed to check browser status</div>`;
            }
        }

        async function installBrowsers() {
            showStatus('Browser installation started. This may take a few minutes...', 'info');
            // Note: Actual installation would need to be done server-side or manually
            showStatus('Please run "npm run install-browsers" in your terminal to install Playwright browsers.', 'info');
        }

        // Test creation
        document.getElementById('createTestForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            // Parse actions if provided
            if (data.actions) {
                try {
                    data.actions = JSON.parse(data.actions);
                } catch (error) {
                    showStatus('Invalid JSON format in actions field', 'error');
                    return;
                }
            } else {
                data.actions = [];
            }
            
            // Check if we're editing an existing test case
            const editId = e.target.dataset.editId;
            const isEdit = editId && editId !== '';
            
            try {
                const url = isEdit ? `/api/test/cases/${editId}` : '/api/test/cases';
                const method = isEdit ? 'PUT' : 'POST';
                
                const response = await apiCall(url, {
                    method: method,
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showStatus(isEdit ? 'Test case updated successfully' : 'Test case created successfully', 'success');
                    e.target.reset();
                    
                    // Reset form state
                    delete e.target.dataset.editId;
                    const submitBtn = e.target.querySelector('button[type="submit"]');
                    submitBtn.textContent = 'Create Test Case';
                    
                    loadTestCases();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Failed to ' + (isEdit ? 'update' : 'create') + ' test case: ' + error.message, 'error');
            }
        });

        // AI parsing functions
        async function parseWithAI() {
            const instructions = document.getElementById('aiInstructions').value;
            if (!instructions) {
                showStatus('Please enter test instructions', 'error');
                return;
            }

            try {
                const response = await apiCall('/api/test/ai/parse', {
                    method: 'POST',
                    body: JSON.stringify({ instructions })
                });

                const result = await response.json();
                
                if (response.ok) {
                    lastParsedTest = result.parsed.testCase;
                    document.getElementById('aiParsedResult').textContent = JSON.stringify(lastParsedTest, null, 2);
                    document.getElementById('aiResult').classList.remove('hidden');
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('AI parsing failed: ' + error.message, 'error');
            }
        }

        async function generateFromURL() {
            const url = prompt('Enter URL to generate test for:');
            if (!url) return;

            // Ask user if they want to auto-execute the test
            const autoExecute = confirm('Do you want to automatically execute the generated test case after creation?');

            showStatus('Opening browser and capturing page screenshot for Grok AI analysis...', 'info');

            try {
                const response = await apiCall('/api/test/ai/generate-from-url', {
                    method: 'POST',
                    body: JSON.stringify({ url, autoExecute })
                });

                const result = await response.json();
                
                if (response.ok) {
                    lastParsedTest = result.testCase;
                    document.getElementById('aiParsedResult').textContent = JSON.stringify(lastParsedTest, null, 2);
                    document.getElementById('aiResult').classList.remove('hidden');
                    
                    if (result.execution) {
                        // Test was auto-executed
                        showStatus(`Test case generated and executed successfully! Status: ${result.execution.status}`, 'success');
                        
                        // Show execution results
                        if (result.execution.steps && result.execution.steps.length > 0) {
                            const stepsInfo = result.execution.steps.map(step => 
                                `${step.stepNumber}. ${step.description} - ${step.status}`
                            ).join('\n');
                            console.log('Execution steps:', stepsInfo);
                        }
                        
                        // Refresh test cases list to show the new saved test
                        loadTestCases();
                    } else {
                        // Just generated, not executed
                        showStatus('Test case generated successfully from Grok AI vision analysis', 'success');
                    }
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('AI generation failed: ' + error.message, 'error');
            }
        }

        async function saveAIParsedTest() {
            if (!lastParsedTest) return;

            try {
                const response = await apiCall('/api/test/cases', {
                    method: 'POST',
                    body: JSON.stringify(lastParsedTest)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showStatus('AI-parsed test case saved successfully', 'success');
                    document.getElementById('aiResult').classList.add('hidden');
                    document.getElementById('aiInstructions').value = '';
                    loadTestCases();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Failed to save test case: ' + error.message, 'error');
            }
        }

        // Auto-save and execute test case (for generate from URL feature)
        async function autoSaveAndExecuteTest() {
            if (!lastParsedTest) return;

            try {
                // First save the test case
                const saveResponse = await apiCall('/api/test/cases', {
                    method: 'POST',
                    body: JSON.stringify(lastParsedTest)
                });

                const saveResult = await saveResponse.json();
                
                if (saveResponse.ok) {
                    showStatus('Test case saved successfully. Now executing...', 'success');
                    
                    // Get the saved test case ID and execute it
                    const testId = saveResult.testCase?.id;
                    if (testId) {
                        // Clear the AI result display
                        document.getElementById('aiResult').classList.add('hidden');
                        document.getElementById('aiInstructions').value = '';
                        
                        // Reload test cases to show the new one
                        await loadTestCases();
                        
                        // Auto-execute the test
                        await executeTest(testId);
                    } else {
                        showStatus('Test case saved but could not auto-execute (missing ID)', 'warning');
                    }
                } else {
                    showStatus('Failed to save test case: ' + (saveResult.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showStatus('Failed to auto-save and execute test case: ' + error.message, 'error');
            }
        }

        // File upload
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload/test-cases', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: formData
                });

                const result = await response.json();
                
                if (response.ok) {
                    showStatus(`Successfully imported ${result.testCases.length} test cases`, 'success');
                    document.getElementById('uploadResult').innerHTML = 
                        `<div class="status success">Imported ${result.testCases.length} test cases from ${result.file.originalName}</div>`;
                    loadTestCases();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('File upload failed: ' + error.message, 'error');
            }
        }

        // Test execution
        async function executeTest(testId) {
            const browserType = document.getElementById('browserType').value;
            const headless = document.getElementById('headlessMode').checked;

            try {
                showStatus('Executing test...', 'info');
                
                const response = await apiCall(`/api/test/execute/${testId}`, {
                    method: 'POST',
                    body: JSON.stringify({ 
                        browserType, 
                        headless, 
                        interactionDelay 
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    showStatus(`Test executed: ${result.result.status}`, 
                        result.result.status === 'success' ? 'success' : 'error');
                    loadTestResults();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Test execution failed: ' + error.message, 'error');
            }
        }

        // Edit test case
        async function editTestCase(testId) {
            try {
                // First get the test case data
                const response = await apiCall(`/api/test/cases/${testId}`);
                const result = await response.json();
                
                if (!response.ok) {
                    showStatus('Failed to load test case: ' + result.error, 'error');
                    return;
                }
                
                const testCase = result.testCase;
                
                // Populate form with existing data
                document.getElementById('testName').value = testCase.name;
                document.getElementById('testDescription').value = testCase.description || '';
                document.getElementById('testUrl').value = testCase.url;
                document.getElementById('testActions').value = JSON.stringify(testCase.actions, null, 2);
                
                // Store the ID for updating
                document.getElementById('createTestForm').dataset.editId = testId;
                
                // Change form submit button text
                const submitBtn = document.querySelector('#createTestForm button[type="submit"]');
                submitBtn.textContent = 'Update Test Case';
                
                // Switch to create test tab
                switchTestTab('create');
                
                showStatus('Test case loaded for editing', 'info');
            } catch (error) {
                showStatus('Failed to load test case: ' + error.message, 'error');
            }
        }

        // Delete test case
        async function deleteTestCase(testId) {
            if (!confirm('Are you sure you want to delete this test case? This will also delete all associated test results.')) {
                return;
            }
            
            try {
                showStatus('Deleting test case...', 'info');
                
                const response = await apiCall(`/api/test/cases/${testId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showStatus('Test case deleted successfully', 'success');
                    loadTestCases();
                    loadTestResults();
                } else {
                    showStatus('Failed to delete test case: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Failed to delete test case: ' + error.message, 'error');
            }
        }

        // Edit test result
        async function editTestResult(resultId) {
            try {
                // Get the test result data
                const response = await apiCall(`/api/test/results/${resultId}`);
                const result = await response.json();
                
                if (!response.ok) {
                    showStatus('Failed to load test result: ' + result.error, 'error');
                    return;
                }
                
                const testResult = result.result;
                
                // Create edit form
                const editForm = `
                    <div id="editResultModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                        <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%;">
                            <h3>Edit Test Result</h3>
                            <form id="editResultForm">
                                <div class="form-group">
                                    <label for="editStatus">Status:</label>
                                    <select id="editStatus" required>
                                        <option value="success" ${testResult.status === 'success' ? 'selected' : ''}>Success</option>
                                        <option value="failed" ${testResult.status === 'failed' ? 'selected' : ''}>Failed</option>
                                        <option value="pending" ${testResult.status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="skipped" ${testResult.status === 'skipped' ? 'selected' : ''}>Skipped</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="editExecutionTime">Execution Time (ms):</label>
                                    <input type="number" id="editExecutionTime" value="${testResult.execution_time || ''}" min="0">
                                </div>
                                <div class="form-group">
                                    <label for="editErrorMessage">Error Message:</label>
                                    <textarea id="editErrorMessage" rows="3">${testResult.error_message || ''}</textarea>
                                </div>
                                <div class="form-group">
                                    <label for="editScreenshotPath">Screenshot Path:</label>
                                    <input type="text" id="editScreenshotPath" value="${testResult.screenshot_path || ''}">
                                </div>
                                <div class="form-group">
                                    <label for="editReportPath">Report Path:</label>
                                    <input type="text" id="editReportPath" value="${testResult.report_path || ''}">
                                </div>
                                <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                                    <button type="submit" class="btn-success">Update Result</button>
                                    <button type="button" onclick="closeEditResultModal()" class="btn-secondary">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', editForm);
                
                // Handle form submission
                document.getElementById('editResultForm').addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const updateData = {
                        status: document.getElementById('editStatus').value,
                        execution_time: parseInt(document.getElementById('editExecutionTime').value) || null,
                        error_message: document.getElementById('editErrorMessage').value.trim() || null,
                        screenshot_path: document.getElementById('editScreenshotPath').value.trim() || null,
                        report_path: document.getElementById('editReportPath').value.trim() || null
                    };
                    
                    try {
                        showStatus('Updating test result...', 'info');
                        
                        const updateResponse = await apiCall(`/api/test/results/${resultId}`, {
                            method: 'PUT',
                            body: JSON.stringify(updateData)
                        });
                        
                        const updateResult = await updateResponse.json();
                        
                        if (updateResponse.ok) {
                            showStatus('Test result updated successfully', 'success');
                            closeEditResultModal();
                            loadTestResults();
                        } else {
                            showStatus('Failed to update test result: ' + updateResult.error, 'error');
                        }
                    } catch (error) {
                        showStatus('Failed to update test result: ' + error.message, 'error');
                    }
                });
                
            } catch (error) {
                showStatus('Failed to load test result: ' + error.message, 'error');
            }
        }

        // Close edit result modal
        function closeEditResultModal() {
            const modal = document.getElementById('editResultModal');
            if (modal) {
                modal.remove();
            }
        }

        // Delete test result
        async function deleteTestResult(resultId) {
            if (!confirm('Are you sure you want to delete this test result?')) {
                return;
            }
            
            try {
                showStatus('Deleting test result...', 'info');
                
                const response = await apiCall(`/api/test/results/${resultId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showStatus('Test result deleted successfully', 'success');
                    loadTestResults();
                } else {
                    showStatus('Failed to delete test result: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Failed to delete test result: ' + error.message, 'error');
            }
        }

        // Show/hide parallel execution options
        document.getElementById('parallelExecution').addEventListener('change', function() {
            const maxConcurrencyGroup = document.getElementById('maxConcurrencyGroup');
            if (this.checked) {
                maxConcurrencyGroup.style.display = 'block';
            } else {
                maxConcurrencyGroup.style.display = 'none';
            }
        });

        async function executeAllTests() {
            const browserType = document.getElementById('browserType').value;
            const headless = document.getElementById('headlessMode').checked;
            const parallel = document.getElementById('parallelExecution').checked;
            const maxConcurrency = parseInt(document.getElementById('maxConcurrency').value);

            try {
                const executionMode = parallel ? 'parallel' : 'sequential';
                showStatus(`Executing all tests in ${executionMode} mode...`, 'info');
                
                const response = await apiCall('/api/test/execute-all', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        browserType, 
                        headless, 
                        parallel, 
                        maxConcurrency,
                        interactionDelay 
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    const mode = result.executionMode || 'sequential';
                    showStatus(`${mode.charAt(0).toUpperCase() + mode.slice(1)} execution completed: ${result.summary.passed}/${result.summary.total} passed`, 'success');
                    loadTestResults();
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Batch execution failed: ' + error.message, 'error');
            }
        }

        // Load test cases
        async function loadTestCases() {
            try {
                const response = await apiCall('/api/test/cases');
                const result = await response.json();
                
                if (response.ok) {
                    const testCasesList = document.getElementById('testCasesList');
                    
                    if (result.testCases.length === 0) {
                        testCasesList.innerHTML = '<p>No test cases found. Create your first test case above.</p>';
                        return;
                    }

                    testCasesList.innerHTML = result.testCases.map(testCase => `
                        <div class="test-case">
                            <h4>${testCase.name}</h4>
                            <p><strong>URL:</strong> ${testCase.url}</p>
                            <p><strong>Description:</strong> ${testCase.description || 'No description'}</p>
                            <p><strong>Actions:</strong> ${testCase.actions.length} step(s)</p>
                            <div class="test-case-actions">
                                <button onclick="executeTest(${testCase.id})" class="btn-success">Run Test</button>
                                <button onclick="editTestCase(${testCase.id})" class="btn-secondary">Edit</button>
                                <button onclick="deleteTestCase(${testCase.id})" class="btn-danger">Delete</button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    document.getElementById('testCasesList').innerHTML = 
                        `<div class="status error">Failed to load test cases</div>`;
                }
            } catch (error) {
                document.getElementById('testCasesList').innerHTML = 
                    `<div class="status error">Failed to load test cases: ${error.message}</div>`;
            }
        }

        // Load test results
        async function loadTestResults() {
            try {
                const response = await apiCall('/api/test/results');
                const result = await response.json();
                
                if (response.ok) {
                    const testResultsList = document.getElementById('testResultsList');
                    
                    if (result.results.length === 0) {
                        testResultsList.innerHTML = '<p>No test results found. Run some tests to see results here.</p>';
                        return;
                    }

                    testResultsList.innerHTML = result.results.map(testResult => `
                        <div class="test-result ${testResult.status === 'failed' ? 'failed' : ''}">
                            <h4>${testResult.test_case_name}</h4>
                            <p><strong>Status:</strong> ${testResult.status.toUpperCase()}</p>
                            <p><strong>Execution Time:</strong> ${testResult.execution_time}ms</p>
                            <p><strong>Executed:</strong> ${new Date(testResult.executed_at).toLocaleString()}</p>
                            ${testResult.error_message ? `<p><strong>Error:</strong> ${testResult.error_message}</p>` : ''}
                            ${testResult.screenshot_path ? `<p><strong>Screenshot:</strong> Available</p>` : ''}
                            <div class="test-result-actions">
                                <button onclick="editTestResult(${testResult.id})" class="btn-secondary">Edit</button>
                                <button onclick="deleteTestResult(${testResult.id})" class="btn-danger">Delete</button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    document.getElementById('testResultsList').innerHTML = 
                        `<div class="status error">Failed to load test results</div>`;
                }
            } catch (error) {
                document.getElementById('testResultsList').innerHTML = 
                    `<div class="status error">Failed to load test results: ${error.message}</div>`;
            }
        }

        // Report generation
        async function generateReport(type) {
            try {
                showStatus(`Generating ${type.toUpperCase()} report...`, 'info');
                
                const response = await apiCall(`/api/reports/generate/${type}`, {
                    method: 'POST',
                    body: JSON.stringify({}) // Include all results
                });

                const result = await response.json();
                
                if (response.ok) {
                    showStatus(`${type.toUpperCase()} report generated successfully`, 'success');
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.href = `/api/reports/download/${result.report.filename}`;
                    link.download = result.report.filename;
                    link.textContent = `Download ${result.report.filename}`;
                    link.style.display = 'block';
                    link.style.margin = '10px 0';
                    
                    document.getElementById('testResultsList').prepend(link);
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus(`Report generation failed: ${error.message}`, 'error');
            }
        }

        // Interaction Recorder functionality
        let isRecording = false;
        let isPaused = false;
        let recordedActions = [];
        let recordingWindow = null;
        let recordingStartTime = null;
        let liveDurationTimer = null;

        function startRecording() {
            const testName = document.getElementById('recordTestName').value.trim();
            const testUrl = document.getElementById('recordTestUrl').value.trim();
            
            if (!testName || !testUrl) {
                showStatus('Please enter both test name and URL to start recording', 'error');
                return;
            }

            // Validate URL
            try {
                new URL(testUrl);
            } catch (e) {
                showStatus('Please enter a valid URL', 'error');
                return;
            }

            isRecording = true;
            isPaused = false;
            recordedActions = [];
            recordingStartTime = Date.now();
            
            // Update UI
            document.getElementById('startRecordingBtn').disabled = true;
            document.getElementById('stopRecordingBtn').disabled = false;
            document.getElementById('pauseRecordingBtn').disabled = false;
            
            // Show recording status
            const statusDiv = document.getElementById('recordingStatus');
            statusDiv.className = 'recording-status active';
            statusDiv.textContent = `🔴 Recording in progress... Target: ${testUrl}`;
            statusDiv.style.display = 'block';
            
            // Show live view panel
            const liveViewPanel = document.getElementById('liveViewPanel');
            liveViewPanel.style.display = 'block';
            document.getElementById('liveActionCount').textContent = '0';
            document.getElementById('liveStatus').textContent = 'Recording...';
            
            // Start live duration timer
            startLiveDurationTimer();
            
            // Hide instructions and show actions panel
            document.getElementById('recordingInstructions').style.display = 'none';
            document.getElementById('recordedActions').style.display = 'block';
            
            // Clear live preview
            const livePreview = document.getElementById('liveActionsPreview');
            livePreview.innerHTML = '<div class="live-action-placeholder">Perform actions on the target page to see them here...</div>';
            
            // Open new window for recording
            recordingWindow = window.open(testUrl, 'recorder', 'width=1200,height=800,scrollbars=yes,resizable=yes');
            
            if (!recordingWindow) {
                showStatus('Failed to open recording window. Please allow popups for this site.', 'error');
                stopRecording();
                return;
            }

            // Set up recording in the new window
            recordingWindow.addEventListener('load', () => {
                setupRecordingInWindow(recordingWindow);
            });

            // Monitor if window is closed
            const checkClosed = setInterval(() => {
                if (recordingWindow.closed) {
                    clearInterval(checkClosed);
                    if (isRecording) {
                        stopRecording();
                    }
                }
            }, 1000);

            showStatus('Recording started! Perform your interactions in the opened window.', 'success');
        }

        function stopRecording() {
            isRecording = false;
            isPaused = false;
            
            // Stop live duration timer
            if (liveDurationTimer) {
                clearInterval(liveDurationTimer);
                liveDurationTimer = null;
            }
            
            // Close recording window if still open
            if (recordingWindow && !recordingWindow.closed) {
                recordingWindow.close();
            }
            
            // Update UI
            document.getElementById('startRecordingBtn').disabled = false;
            document.getElementById('stopRecordingBtn').disabled = true;
            document.getElementById('pauseRecordingBtn').disabled = true;
            
            // Update status
            const statusDiv = document.getElementById('recordingStatus');
            statusDiv.className = 'recording-status stopped';
            statusDiv.textContent = `⏹️ Recording stopped. Captured ${recordedActions.length} actions.`;
            
            // Hide live view panel
            document.getElementById('liveViewPanel').style.display = 'none';
            
            // Show instructions again
            document.getElementById('recordingInstructions').style.display = 'block';
            
            showStatus(`Recording completed with ${recordedActions.length} actions`, 'success');
            updateActionsDisplay();
        }

        function pauseRecording() {
            if (isRecording) {
                isPaused = !isPaused;
                
                const statusDiv = document.getElementById('recordingStatus');
                const pauseBtn = document.getElementById('pauseRecordingBtn');
                const liveStatus = document.getElementById('liveStatus');
                
                if (isPaused) {
                    statusDiv.className = 'recording-status paused';
                    statusDiv.textContent = '⏸️ Recording paused';
                    pauseBtn.textContent = '▶️ Resume Recording';
                    liveStatus.textContent = 'Paused';
                    
                    // Pause live duration timer
                    if (liveDurationTimer) {
                        clearInterval(liveDurationTimer);
                        liveDurationTimer = null;
                    }
                } else {
                    statusDiv.className = 'recording-status active';
                    statusDiv.textContent = '🔴 Recording in progress...';
                    pauseBtn.textContent = '⏸️ Pause Recording';
                    liveStatus.textContent = 'Recording...';
                    
                    // Resume live duration timer
                    startLiveDurationTimer();
                }
            }
        }

        function startLiveDurationTimer() {
            if (liveDurationTimer) {
                clearInterval(liveDurationTimer);
            }
            
            liveDurationTimer = setInterval(() => {
                if (isRecording && !isPaused && recordingStartTime) {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('liveDuration').textContent = timeString;
                }
            }, 1000);
        }

        function setupRecordingInWindow(win) {
            try {
                const doc = win.document;
                
                // Wait for document to be ready before injecting script
                const waitForDocumentReady = () => {
                    if (doc.readyState === 'loading') {
                        setTimeout(waitForDocumentReady, 100);
                        return;
                    }
                    
                    // Inject recording script into the window
                    const script = doc.createElement('script');
                    script.textContent = `
                    (function() {
                        console.log('Recording script initialized on:', window.location.href);
                        let actionSequence = 0;
                        let setupComplete = false;
                        
                        // Action deduplication tracking
                        let recentActions = new Map(); // selector -> {type, timestamp, value}
                        const DEDUP_WINDOW = 500; // 500ms window for deduplication
                        
                        // Enhanced function to capture actions with deduplication and filtering
                        function captureAction(type, target, value, description) {
                            try {
                                if (!window.opener) {
                                    console.error('Recording: window.opener is not available');
                                    return;
                                }
                                
                                if (!window.opener.addRecordedAction) {
                                    console.error('Recording: addRecordedAction function not found in opener');
                                    return;
                                }
                                
                                const selector = generateSelector(target);
                                const now = Date.now();
                                const actionKey = selector + ':' + type;
                                
                                // Check for duplicate actions within the deduplication window
                                if (recentActions.has(actionKey)) {
                                    const recent = recentActions.get(actionKey);
                                    if (now - recent.timestamp < DEDUP_WINDOW) {
                                        // Skip if same type and value within time window
                                        if (recent.value === value) {
                                            console.log('Skipping duplicate action:', type, selector, value);
                                            return;
                                        }
                                    }
                                }
                                
                                // Filter out redundant events based on element type and action type
                                if (shouldSkipAction(type, target, value)) {
                                    console.log('Skipping redundant action:', type, selector, value);
                                    return;
                                }
                                
                                // Update recent actions tracking
                                recentActions.set(actionKey, {
                                    timestamp: now,
                                    value: value,
                                    type: type
                                });
                                
                                // Clean up old entries
                                cleanupRecentActions(now);
                                
                                const action = {
                                    type: type,
                                    selector: selector,
                                    locator: selector,
                                    value: value || '',
                                    description: description,
                                    timestamp: now,
                                    sequence: ++actionSequence,
                                    url: window.location.href
                                };
                                
                                console.log('Recording action:', action);
                                
                                // Add visual feedback for the action
                                highlightElement(target, type);
                                
                                window.opener.addRecordedAction(action);
                            } catch (error) {
                                console.error('Recording: Failed to capture action:', error);
                            }
                        }
                        
                        // Determine if an action should be skipped to reduce noise
                        function shouldSkipAction(type, target, value) {
                            const tagName = target.tagName.toLowerCase();
                            const inputType = target.type ? target.type.toLowerCase() : '';
                            
                            // For SELECT elements, prefer 'change' events over 'input' events
                            if (tagName === 'select' && type === 'input') {
                                return true;
                            }
                            
                            // For checkboxes and radio buttons, prefer 'change' events over 'input' events
                            if ((inputType === 'checkbox' || inputType === 'radio') && type === 'input') {
                                return true;
                            }
                            
                            // Skip click events on form inputs that also have input/change events
                            if (type === 'click' && ['input', 'textarea', 'select'].includes(tagName)) {
                                return true;
                            }
                            
                            // Skip input events with empty values (often fired during focus/blur)
                            if (type === 'input' && (!value || value.trim() === '')) {
                                return true;
                            }
                            
                            return false;
                        }
                        
                        // Clean up old entries from recent actions map
                        function cleanupRecentActions(now) {
                            for (const [key, action] of recentActions.entries()) {
                                if (now - action.timestamp > DEDUP_WINDOW * 2) {
                                    recentActions.delete(key);
                                }
                            }
                        }
                        
                        // Add visual feedback when element is interacted with
                        function highlightElement(element, actionType) {
                            if (!element) return;
                            
                            try {
                                const originalBorder = element.style.border;
                                const originalBoxShadow = element.style.boxShadow;
                                
                                element.style.border = '3px solid #28a745';
                                element.style.boxShadow = '0 0 10px rgba(40, 167, 69, 0.5)';
                                
                                // Create action label
                                const label = document.createElement('div');
                                label.style.cssText = \`
                                    position: absolute;
                                    background: #28a745;
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 3px;
                                    font-size: 11px;
                                    font-family: Arial, sans-serif;
                                    z-index: 10001;
                                    pointer-events: none;
                                \`;
                                label.textContent = \`🤖 \${actionType.charAt(0).toUpperCase() + actionType.slice(1)}ing...\`;
                                
                                const rect = element.getBoundingClientRect();
                                label.style.left = (rect.left + window.scrollX) + 'px';
                                label.style.top = (rect.top + window.scrollY - 25) + 'px';
                                
                                document.body.appendChild(label);
                                
                                // Remove highlighting after 2 seconds
                                setTimeout(() => {
                                    element.style.border = originalBorder;
                                    element.style.boxShadow = originalBoxShadow;
                                    if (label.parentNode) {
                                        label.parentNode.removeChild(label);
                                    }
                                }, 2000);
                            } catch (error) {
                                console.error('Recording: Failed to highlight element:', error);
                            }
                        }
                        
                        // Enhanced selector generation
                        function generateSelector(element) {
                            if (!element) return 'unknown';
                            
                            // Priority order: id, name, data attributes, text content, class, tag
                            if (element.id) {
                                return '#' + element.id;
                            }
                            
                            if (element.name) {
                                return \`[name="\${element.name}"]\`;
                            }
                            
                            // Check for data attributes
                            if (element.dataset.testid) {
                                return \`[data-testid="\${element.dataset.testid}"]\`;
                            }
                            
                            if (element.dataset.cy) {
                                return \`[data-cy="\${element.dataset.cy}"]\`;
                            }
                            
                            // For buttons and links, prefer text content
                            if ((element.tagName === 'BUTTON' || element.tagName === 'A') && element.textContent && element.textContent.trim()) {
                                const text = element.textContent.trim().substring(0, 30);
                                return \`text=\${text}\`;
                            }
                            
                            // For form inputs, try placeholder or label
                            if (element.placeholder) {
                                return \`[placeholder="\${element.placeholder}"]\`;
                            }
                            
                            // Build CSS selector with class
                            let selector = element.tagName.toLowerCase();
                            if (element.className && element.className.trim()) {
                                const classes = element.className.trim().split(/\\s+/).slice(0, 3); // Limit to 3 classes
                                selector += '.' + classes.join('.');
                            }
                            
                            return selector;
                        }
                        
                        // Wait for DOM to be ready with retry mechanism
                        function initRecording() {
                            if (setupComplete) return;
                            
                            console.log('Recording: DOM ready, setting up event listeners');
                            
                            // Verify opener connection
                            if (window.opener) {
                                console.log('Recording: window.opener available');
                                if (typeof window.opener.isRecordingActive === 'function') {
                                    console.log('Recording: isRecordingActive function found');
                                } else {
                                    console.error('Recording: isRecordingActive function not found');
                                }
                                if (typeof window.opener.addRecordedAction === 'function') {
                                    console.log('Recording: addRecordedAction function found');
                                } else {
                                    console.error('Recording: addRecordedAction function not found');
                                }
                            } else {
                                console.error('Recording: window.opener not available');
                                // Retry after a short delay
                                setTimeout(initRecording, 500);
                                return;
                            }
                            
                            setupComplete = true;
                            setupEventListeners();
                        }
                        
                        function setupEventListeners() {
                            // Track clicks with improved filtering
                            document.addEventListener('click', function(e) {
                                try {
                                    if (window.opener && window.opener.isRecordingActive() && !window.opener.isRecordingPaused()) {
                                        const target = e.target;
                                        const tagName = target.tagName.toLowerCase();
                                        
                                        // Skip clicks on form inputs as they'll be handled by input/change events
                                        if (['input', 'textarea', 'select'].includes(tagName)) {
                                            return;
                                        }
                                        
                                        let description = 'Click ';
                                        
                                        if (target.textContent && target.textContent.trim()) {
                                            description += target.textContent.trim().substring(0, 30);
                                        } else if (target.alt) {
                                            description += target.alt;
                                        } else if (target.title) {
                                            description += target.title;
                                        } else {
                                            description += target.tagName.toLowerCase();
                                        }
                                        
                                        captureAction('click', target, '', description);
                                    }
                                } catch (error) {
                                    console.error('Recording: Click tracking failed:', error);
                                }
                            }, true);
                            
                            // Track input changes with improved debouncing
                            let inputTimeouts = new Map();
                            document.addEventListener('input', function(e) {
                                try {
                                    if (window.opener && window.opener.isRecordingActive() && !window.opener.isRecordingPaused()) {
                                        const target = e.target;
                                        const selector = generateSelector(target);
                                        
                                        // Clear previous timeout for this element
                                        if (inputTimeouts.has(selector)) {
                                            clearTimeout(inputTimeouts.get(selector));
                                        }
                                        
                                        // Set new timeout
                                        const timeout = setTimeout(() => {
                                            if (target.type === 'password') {
                                                captureAction('input', target, '***', 'Enter password');
                                            } else {
                                                const value = target.value || '';
                                                if (value.trim()) { // Only capture non-empty values
                                                    const description = \`Enter text: \${value.substring(0, 20)}\${value.length > 20 ? '...' : ''}\`;
                                                    captureAction('input', target, value, description);
                                                }
                                            }
                                            inputTimeouts.delete(selector);
                                        }, 500); // Increased debounce to 500ms
                                        
                                        inputTimeouts.set(selector, timeout);
                                    }
                                } catch (error) {
                                    console.error('Recording: Input tracking failed:', error);
                                }
                            }, true);
                            
                            // Track change events (preferred for dropdowns, checkboxes, radio buttons)
                            document.addEventListener('change', function(e) {
                                try {
                                    if (window.opener && window.opener.isRecordingActive() && !window.opener.isRecordingPaused()) {
                                        const target = e.target;
                                        const tagName = target.tagName.toLowerCase();
                                        const inputType = target.type ? target.type.toLowerCase() : '';
                                        
                                        if (inputType === 'checkbox') {
                                            captureAction('checkbox', target, target.checked, \`\${target.checked ? 'Check' : 'Uncheck'} checkbox\`);
                                        } else if (inputType === 'radio') {
                                            captureAction('radio', target, target.value, \`Select radio: \${target.value}\`);
                                        } else if (tagName === 'select') {
                                            const selectedText = target.options[target.selectedIndex]?.text || target.value;
                                            captureAction('select', target, target.value, \`Select option: \${selectedText}\`);
                                        } else if (['input', 'textarea'].includes(tagName) && !['checkbox', 'radio'].includes(inputType)) {
                                            // Handle other input types that might not fire input events
                                            const value = target.value || '';
                                            if (value.trim()) {
                                                const description = \`Enter text: \${value.substring(0, 20)}\${value.length > 20 ? '...' : ''}\`;
                                                captureAction('input', target, value, description);
                                            }
                                        }
                                    }
                                } catch (error) {
                                    console.error('Recording: Change tracking failed:', error);
                                }
                            }, true);
                            
                            // Track form submissions
                            document.addEventListener('submit', function(e) {
                                try {
                                    if (window.opener && window.opener.isRecordingActive() && !window.opener.isRecordingPaused()) {
                                        captureAction('submit', e.target, '', 'Submit form');
                                    }
                                } catch (error) {
                                    console.error('Recording: Submit tracking failed:', error);
                                }
                            }, true);
                            
                            // Track navigation with improved detection
                            let lastUrl = window.location.href;
                            const checkUrlChange = () => {
                                try {
                                    if (window.location.href !== lastUrl) {
                                        if (window.opener && window.opener.isRecordingActive() && !window.opener.isRecordingPaused()) {
                                            window.opener.addRecordedAction({
                                                type: 'navigate',
                                                selector: '',
                                                locator: '',
                                                value: window.location.href,
                                                description: 'Navigate to ' + window.location.href,
                                                timestamp: Date.now(),
                                                sequence: ++actionSequence
                                            });
                                        }
                                        lastUrl = window.location.href;
                                    }
                                } catch (error) {
                                    console.error('Recording: Navigation tracking failed:', error);
                                }
                            };
                            
                            // Check for URL changes every 500ms and on popstate
                            setInterval(checkUrlChange, 500);
                            window.addEventListener('popstate', checkUrlChange);
                            
                            console.log('Recording: All event listeners set up successfully');
                        }
                        
                        // Initialize with retry mechanism
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', initRecording);
                        } else {
                            initRecording();
                        }
                        
                        // Fallback initialization after a delay
                        setTimeout(() => {
                            if (!setupComplete) {
                                console.log('Recording: Fallback initialization');
                                initRecording();
                            }
                        }, 1000);
                    })();
                `;
                
                try {
                    doc.head.appendChild(script);
                    console.log('Recording script injected successfully');
                } catch (scriptError) {
                    console.error('Failed to inject recording script:', scriptError);
                    showStatus('Recording script injection failed. The target site may block script injection.', 'error');
                    return;
                }
                
                // Add visual indicator with retry mechanism
                const addIndicator = () => {
                    try {
                        if (!doc.body) {
                            setTimeout(addIndicator, 100);
                            return;
                        }
                        
                        const indicator = doc.createElement('div');
                        indicator.id = 'recording-indicator';
                        indicator.style.cssText = `
                            position: fixed;
                            top: 10px;
                            right: 10px;
                            background: #ff4444;
                            color: white;
                            padding: 10px;
                            border-radius: 5px;
                            z-index: 10000;
                            font-family: Arial, sans-serif;
                            font-size: 14px;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                            animation: pulse 2s infinite;
                        `;
                        indicator.innerHTML = '🔴 Recording in Progress';
                        
                        // Add CSS animation
                        const style = doc.createElement('style');
                        style.textContent = `
                            @keyframes pulse {
                                0% { opacity: 1; }
                                50% { opacity: 0.5; }
                                100% { opacity: 1; }
                            }
                        `;
                        doc.head.appendChild(style);
                        doc.body.appendChild(indicator);
                        
                        console.log('Recording indicator added successfully');
                    } catch (indicatorError) {
                        console.error('Failed to add recording indicator:', indicatorError);
                    }
                };
                
                addIndicator();
                };
                
                // Start the setup process
                waitForDocumentReady();
                
            } catch (error) {
                console.error('Failed to setup recording in window:', error);
                showStatus('Failed to setup recording. The target site may not allow recording due to security restrictions.', 'error');
            }
        }

        // Global functions for the recording window to call
        window.addRecordedAction = function(action) {
            if (isRecording && !isPaused) {
                // Apply simple deduplication logic
                if (shouldIncludeAction(action)) {
                    recordedActions.push(action);
                    updateActionsDisplay();
                    updateLiveView(action);
                    console.log('Action included:', action.type, action.selector);
                } else {
                    console.log('Action filtered out:', action.type, action.selector);
                }
            }
        };

        // Simple and effective deduplication logic
        function shouldIncludeAction(newAction) {
            // For the first action, always include it
            if (recordedActions.length === 0) {
                return true;
            }
            
            // Get the most recent action
            const lastAction = recordedActions[recordedActions.length - 1];
            
            // If it's the same selector within 1 second, apply filtering rules
            if (lastAction.selector === newAction.selector && 
                newAction.timestamp - lastAction.timestamp < 1000) {
                
                // For SELECT elements: keep SELECT, skip INPUT
                if (lastAction.type === 'select' && newAction.type === 'input') {
                    return false;
                }
                
                // For checkboxes: keep CHECKBOX, skip INPUT events with value 'on'
                if (lastAction.type === 'checkbox' && newAction.type === 'input' && 
                    (newAction.value === 'on' || newAction.value === true)) {
                    return false;
                }
                
                // Skip click events on form elements if we have a more specific action
                if ((lastAction.type === 'input' || lastAction.type === 'checkbox' || lastAction.type === 'select') && 
                    newAction.type === 'click') {
                    return false;
                }
                
                // Skip exact duplicates
                if (lastAction.type === newAction.type && lastAction.value === newAction.value) {
                    return false;
                }
            }
            
            return true;
        }


        window.isRecordingActive = function() {
            return isRecording;
        };

        window.isRecordingPaused = function() {
            return isPaused;
        };

        function updateLiveView(action) {
            // Update live action count
            document.getElementById('liveActionCount').textContent = recordedActions.length;
            
            // Add action to live preview
            const livePreview = document.getElementById('liveActionsPreview');
            
            // Remove placeholder if it exists
            const placeholder = livePreview.querySelector('.live-action-placeholder');
            if (placeholder) {
                placeholder.remove();
            }
            
            // Create live action item
            const actionItem = document.createElement('div');
            actionItem.className = 'live-action-item';
            
            // Format time
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            actionItem.innerHTML = `
                <div class="live-action-type">${action.type}</div>
                <div class="live-action-description">${action.description}</div>
                <div class="live-action-time">${timeString}</div>
            `;
            
            // Add to top of preview (most recent first)
            livePreview.insertBefore(actionItem, livePreview.firstChild);
            
            // Limit to 10 most recent actions in live view
            const items = livePreview.querySelectorAll('.live-action-item');
            if (items.length > 10) {
                items[items.length - 1].remove();
            }
            
            // Scroll to top to show latest action
            livePreview.scrollTop = 0;
        }

        function updateActionsDisplay() {
            const actionsList = document.getElementById('actionsList');
            actionsList.innerHTML = '';
            
            recordedActions.forEach((action, index) => {
                const actionDiv = document.createElement('div');
                actionDiv.className = 'action-item';
                actionDiv.innerHTML = `
                    <div class="action-details">
                        <div class="action-type">${action.type.toUpperCase()}</div>
                        <div class="action-target">${action.selector}</div>
                        ${action.value ? `<div class="action-value">Value: ${action.value}</div>` : ''}
                    </div>
                    <button class="action-remove" onclick="removeAction(${index})">Remove</button>
                `;
                actionsList.appendChild(actionDiv);
            });
        }

        function removeAction(index) {
            recordedActions.splice(index, 1);
            updateActionsDisplay();
        }

        function clearRecordedActions() {
            recordedActions = [];
            updateActionsDisplay();
            
            // Clear live view
            document.getElementById('liveActionCount').textContent = '0';
            const livePreview = document.getElementById('liveActionsPreview');
            livePreview.innerHTML = '<div class="live-action-placeholder">Perform actions on the target page to see them here...</div>';
            
            document.getElementById('recordedActions').style.display = 'none';
            document.getElementById('recordingInstructions').style.display = 'block';
        }

        // Browse and Generate functionality
        async function browseAndGenerate() {
            const url = prompt('Enter URL to browse and generate test from:');
            if (!url) return;

            // Validate URL
            try {
                new URL(url);
            } catch {
                showStatus('Please enter a valid URL', 'error');
                return;
            }

            const autoExecute = confirm('Do you want to automatically execute the generated test case?\n\nClick OK to auto-execute, or Cancel to just generate the test.');

            try {
                showStatus('📸 Taking screenshot and analyzing page...', 'info');
                
                const response = await apiCall('/api/test/ai/browse-and-generate', {
                    method: 'POST',
                    body: JSON.stringify({ url, autoExecute })
                });

                const result = await response.json();
                
                if (response.ok) {
                    lastParsedTest = result.testCase;
                    document.getElementById('aiParsedResult').textContent = JSON.stringify(lastParsedTest, null, 2);
                    document.getElementById('aiResult').classList.remove('hidden');
                    
                    if (autoExecute && result.execution) {
                        showStatus(`✅ Test case generated and executed! Status: ${result.execution.status}. Execution time: ${result.execution.executionTime}ms`, 'success');
                        loadTestCases(); // Refresh the test cases list
                    } else {
                        showStatus('🔍 Test case generated successfully from screenshot analysis!', 'success');
                    }
                } else {
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                showStatus('Browse and generate failed: ' + error.message, 'error');
            }
        }

        // Save and execute AI parsed test (for the new Save & Execute button)
        async function saveAndExecuteAIParsedTest() {
            if (!lastParsedTest) return;

            try {
                showStatus('Saving and executing test case...', 'info');
                
                // First save the test case
                const saveResponse = await apiCall('/api/test/cases', {
                    method: 'POST',
                    body: JSON.stringify(lastParsedTest)
                });

                const saveResult = await saveResponse.json();
                
                if (saveResponse.ok) {
                    const testCaseId = saveResult.id;
                    
                    // Now execute the test case
                    const executeResponse = await apiCall(`/api/test/execute/${testCaseId}`, {
                        method: 'POST',
                        body: JSON.stringify({
                            browserType: 'chromium',
                            headless: true,
                            interactionDelay: 2
                        })
                    });

                    const executeResult = await executeResponse.json();
                    
                    if (executeResponse.ok) {
                        showStatus(`Test case saved and executed successfully! Status: ${executeResult.result.status}`, 'success');
                        document.getElementById('aiResult').classList.add('hidden');
                        document.getElementById('aiInstructions').value = '';
                        loadTestCases();
                    } else {
                        showStatus('Test saved but execution failed: ' + executeResult.error, 'warning');
                        loadTestCases();
                    }
                } else {
                    showStatus('Failed to save test case: ' + saveResult.error, 'error');
                }
            } catch (error) {
                showStatus('Failed to save and execute test case: ' + error.message, 'error');
            }
        }

        function saveRecordedTest() {
            const testName = document.getElementById('recordTestName').value.trim();
            const testUrl = document.getElementById('recordTestUrl').value.trim();
            const testDescription = document.getElementById('recordTestDescription').value.trim();
            
            if (!testName || !testUrl) {
                showStatus('Please enter test name and URL', 'error');
                return;
            }
            
            if (recordedActions.length === 0) {
                showStatus('No actions recorded. Please record some interactions first.', 'error');
                return;
            }
            
            // Convert recorded actions to test case format
            const testCase = {
                name: testName,
                description: testDescription || `Recorded test case with ${recordedActions.length} actions`,
                url: testUrl,
                actions: recordedActions.map(action => ({
                    type: action.type,
                    locator: action.locator,
                    value: action.value,
                    description: action.description
                }))
            };
            
            // Save the test case
            createTestCase(testCase);
        }
    </script>
</body>
</html>